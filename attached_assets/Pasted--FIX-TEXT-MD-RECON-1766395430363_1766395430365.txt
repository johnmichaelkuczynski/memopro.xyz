═══════════════════════════════════════════════════════════════════════════════
FIX: TEXT MD (RECONSTRUCTION) — INSTRUCTION COMPLIANCE FAILURE
═══════════════════════════════════════════════════════════════════════════════

PROBLEM SUMMARY
───────────────
User gave these instructions:
  "Reduce length to 20,000 words (no less). Write a concluding chapter that 
   summarizes each of the preceding chapters and adds a paragraph or so on 
   possible directions for future research."

The output:
  1. Has NO concluding chapter
  2. Has visible truncations (sentences cut off mid-word)
  3. May have dropped or merged chapters
  4. Ends abruptly with a references section

This is a critical failure. The user's explicit instruction was ignored.

═══════════════════════════════════════════════════════════════════════════════
ISSUE 1: USER INSTRUCTIONS NOT CAPTURED IN SKELETON
═══════════════════════════════════════════════════════════════════════════════

PROBLEM:
The skeleton extraction phase must capture user instructions, not just 
document structure. The instruction to "write a concluding chapter" was
either not captured or not enforced.

FIX:
Add a dedicated field in the skeleton for user instructions:

```javascript
const skeleton = {
    // Existing fields
    thesis: "...",
    outline: [...],
    key_terms: {...},
    commitment_ledger: {...},
    
    // NEW: User instructions (MANDATORY)
    user_instructions: {
        length_target: 20000,
        length_constraint: "no less than",
        
        // CRITICAL: Capture any content generation instructions
        content_additions: [
            {
                type: "concluding_chapter",
                requirement: "summarize each preceding chapter",
                additional: "add paragraph on future research directions"
            }
        ],
        
        // Track what must be ADDED vs what must be PRESERVED
        must_add: ["concluding chapter with chapter summaries", "future research section"],
        must_preserve: ["all chapter arguments", "academic structure"]
    }
};
```

VALIDATION:
Before processing begins, check:
```javascript
function validateUserInstructions(skeleton) {
    if (skeleton.user_instructions.content_additions.length > 0) {
        console.log("USER REQUESTS NEW CONTENT:");
        for (const addition of skeleton.user_instructions.content_additions) {
            console.log(`  - ${addition.type}: ${addition.requirement}`);
        }
    }
    
    // Flag these for the FINAL stage, not chunk processing
    return skeleton.user_instructions.must_add;
}
```

═══════════════════════════════════════════════════════════════════════════════
ISSUE 2: NO CHAPTER TRACKING
═══════════════════════════════════════════════════════════════════════════════

PROBLEM:
The system doesn't track individual chapters. When the user says "summarize 
each of the preceding chapters," the system must know:
  1. How many chapters exist
  2. What each chapter is about
  3. Whether each chapter survived processing

The input had ~21 distinct essays/chapters. The output may have dropped some.

FIX:
Add chapter tracking to the skeleton:

```javascript
const skeleton = {
    // ... other fields ...
    
    chapters: [
        {
            index: 1,
            title: "AI Logic vs. Classical Logic: Discovery vs. Formalization",
            main_thesis: "Classical logic fails as reasoning tool; System L succeeds",
            start_word: 0,
            end_word: 2500,
            status: "pending"  // → "processed" → "verified"
        },
        {
            index: 2,
            title: "How AI Falsifies the Enumerative Model of Induction",
            main_thesis: "AI demonstrates non-enumerative inductive reasoning",
            start_word: 2501,
            end_word: 4200,
            status: "pending"
        },
        // ... all 21 chapters ...
    ],
    
    chapter_count: 21
};
```

VALIDATION:
After processing, verify all chapters present:

```javascript
function validateChapterPresence(output, skeleton) {
    const outputChapters = extractChapterTitles(output);
    const expectedChapters = skeleton.chapters.map(c => c.title);
    
    const missing = [];
    for (const expected of expectedChapters) {
        // Fuzzy match in case title slightly changed
        if (!outputChapters.some(o => similarEnough(o, expected))) {
            missing.push(expected);
        }
    }
    
    if (missing.length > 0) {
        throw new Error(
            `CHAPTER LOSS DETECTED: Missing ${missing.length} chapters:\n` +
            missing.map(m => `  - ${m}`).join('\n')
        );
    }
    
    return true;
}
```

═══════════════════════════════════════════════════════════════════════════════
ISSUE 3: NO CONCLUDING CHAPTER GENERATION
═══════════════════════════════════════════════════════════════════════════════

PROBLEM:
Even if the skeleton captured the instruction, there's no mechanism to 
GENERATE new content (the concluding chapter) after processing existing 
content.

FIX:
Add a POST-PROCESSING stage for content additions:

```javascript
async function generateRequestedAdditions(processedOutput, skeleton) {
    const additions = skeleton.user_instructions.content_additions;
    
    for (const addition of additions) {
        if (addition.type === "concluding_chapter") {
            const concludingChapter = await generateConcludingChapter(
                processedOutput,
                skeleton
            );
            processedOutput = processedOutput + "\n\n" + concludingChapter;
        }
    }
    
    return processedOutput;
}

async function generateConcludingChapter(document, skeleton) {
    const prompt = `
You are writing a concluding chapter for an academic work.

THE DOCUMENT HAS ${skeleton.chapter_count} CHAPTERS:
${skeleton.chapters.map(c => `${c.index}. "${c.title}" — ${c.main_thesis}`).join('\n')}

YOUR TASK:
Write a concluding chapter that:
1. Has a title like "Conclusion: Synthesis and Future Directions"
2. Contains ONE PARAGRAPH summarizing EACH of the ${skeleton.chapter_count} chapters
3. After the summaries, adds 2-3 paragraphs on future research directions
4. Maintains the academic tone of the document

STRUCTURE:
- Opening paragraph: State the work's overall thesis and contribution
- ${skeleton.chapter_count} summary paragraphs (one per chapter, ~100-150 words each)
- Future research section: 2-3 paragraphs identifying open questions

LENGTH: Approximately ${skeleton.chapter_count * 125 + 500} words

Write the concluding chapter now:
`;

    const result = await callLLM(prompt, { max_tokens: 4000 });
    return result;
}
```

═══════════════════════════════════════════════════════════════════════════════
ISSUE 4: TRUNCATION DETECTION
═══════════════════════════════════════════════════════════════════════════════

PROBLEM:
Multiple sentences in the output are cut off mid-word:
  - "Reichenbach, H. (1938). *Experience"  (truncated)
  - "By treating all" (sentence incomplete)
  - "et al., 2020): 1. Processing of abstract structure" (context lost)

This indicates chunk boundaries are cutting through sentences.

FIX:
Add truncation detection to each chunk output:

```javascript
function detectTruncation(chunkOutput) {
    const truncationIndicators = [
        // Ends with incomplete word (letter followed by nothing)
        /[a-z]$/,
        
        // Ends with opening punctuation
        /[\(\[\{\"\']\s*$/,
        
        // Ends with conjunction or preposition
        /\b(and|or|but|the|a|an|of|in|to|for|with|by|from)\s*$/i,
        
        // Ends with asterisk (markdown formatting)
        /\*\s*$/,
        
        // Reference list cut off (author year pattern with no closing)
        /\(\d{4}\)\.\s*\*[^*]*$/,
        
        // Numbered list item with no content
        /\d+\.\s*$/
    ];
    
    const trimmed = chunkOutput.trim();
    
    for (const pattern of truncationIndicators) {
        if (pattern.test(trimmed)) {
            return {
                truncated: true,
                pattern: pattern.toString(),
                lastChars: trimmed.slice(-50)
            };
        }
    }
    
    // Check for sentence completion
    if (!/[.!?\"\']\s*$/.test(trimmed)) {
        return {
            truncated: true,
            reason: "Does not end with sentence-ending punctuation",
            lastChars: trimmed.slice(-50)
        };
    }
    
    return { truncated: false };
}
```

ENFORCEMENT:
```javascript
async function processChunk(chunk, skeleton, chunkIndex) {
    const output = await callLLM(buildChunkPrompt(chunk, skeleton));
    
    const truncationCheck = detectTruncation(output);
    if (truncationCheck.truncated) {
        console.warn(`Chunk ${chunkIndex} may be truncated: ${truncationCheck.lastChars}`);
        
        // Attempt to complete the chunk
        const completion = await completeChunk(output, skeleton);
        return output + completion;
    }
    
    return output;
}
```

═══════════════════════════════════════════════════════════════════════════════
ISSUE 5: FINAL VALIDATION MISSING
═══════════════════════════════════════════════════════════════════════════════

PROBLEM:
There's no final check that user instructions were actually followed.

FIX:
Add mandatory final validation:

```javascript
async function validateFinalOutput(output, skeleton) {
    const errors = [];
    const warnings = [];
    
    // CHECK 1: Word count
    const wordCount = output.split(/\s+/).length;
    const target = skeleton.user_instructions.length_target;
    const constraint = skeleton.user_instructions.length_constraint;
    
    if (constraint === "no less than" && wordCount < target) {
        errors.push(`Word count ${wordCount} is below minimum ${target}`);
    }
    if (constraint === "no more than" && wordCount > target) {
        errors.push(`Word count ${wordCount} exceeds maximum ${target}`);
    }
    
    // CHECK 2: Required additions present
    for (const required of skeleton.user_instructions.must_add) {
        if (required.includes("concluding chapter")) {
            // Look for concluding chapter markers
            const hasConclusion = /conclusion|synthesis|summary|final chapter/i.test(output);
            const hasFutureResearch = /future research|future directions|further study/i.test(output);
            
            if (!hasConclusion) {
                errors.push("Missing required concluding chapter");
            }
            if (!hasFutureResearch) {
                errors.push("Missing required future research section");
            }
        }
    }
    
    // CHECK 3: Chapter count preserved
    if (skeleton.chapters) {
        const expectedCount = skeleton.chapters.length;
        const foundChapters = countChaptersInOutput(output);
        
        if (foundChapters < expectedCount) {
            errors.push(`Only ${foundChapters} of ${expectedCount} chapters found in output`);
        }
    }
    
    // CHECK 4: No truncations
    const truncationCheck = detectTruncation(output);
    if (truncationCheck.truncated) {
        errors.push(`Output appears truncated: ${truncationCheck.lastChars}`);
    }
    
    // FAIL if any errors
    if (errors.length > 0) {
        throw new Error(
            "FINAL VALIDATION FAILED:\n" + 
            errors.map(e => `  ERROR: ${e}`).join('\n')
        );
    }
    
    return { valid: true, warnings };
}
```

═══════════════════════════════════════════════════════════════════════════════
REVISED PROCESSING PIPELINE
═══════════════════════════════════════════════════════════════════════════════

The full pipeline should now be:

```
1. PARSE USER INSTRUCTIONS
   ↓
   Extract: length target, content additions, constraints
   ↓
2. EXTRACT SKELETON
   ↓
   Include: chapters list, thesis per chapter, user instructions
   ↓
3. VALIDATE SKELETON
   ↓
   Confirm: all chapters identified, instructions captured
   ↓
4. PROCESS CHUNKS (existing CC logic)
   ↓
   For each chunk: process, check truncation, validate
   ↓
5. STITCH PASS
   ↓
   Verify: all chapters present, no contradictions
   ↓
6. GENERATE REQUESTED ADDITIONS  ← NEW STAGE
   ↓
   If user requested new content (e.g., concluding chapter), generate it
   ↓
7. FINAL VALIDATION  ← NEW STAGE
   ↓
   Check: word count, required additions, chapter count, no truncation
   ↓
8. DELIVER OUTPUT
```

═══════════════════════════════════════════════════════════════════════════════
IMPLEMENTATION CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

[ ] 1. Add user_instructions field to skeleton
[ ] 2. Parse user message for content addition requests
[ ] 3. Add chapters array to skeleton with titles and theses
[ ] 4. Implement truncation detection for each chunk
[ ] 5. Add post-processing stage for content additions
[ ] 6. Implement generateConcludingChapter function
[ ] 7. Add final validation stage
[ ] 8. Fail with clear error if validation fails — do NOT deliver incomplete output

═══════════════════════════════════════════════════════════════════════════════
TEST CASE
═══════════════════════════════════════════════════════════════════════════════

INPUT: 31,000 word document with 21 chapters
INSTRUCTION: "Reduce to 20,000 words. Write concluding chapter summarizing 
              each chapter with future research directions."

EXPECTED OUTPUT:
- ~18,000 words of compressed original content
- ~2,000-2,500 word concluding chapter containing:
  - 21 summary paragraphs (one per chapter)
  - 2-3 paragraphs on future research
- Total: ~20,000-20,500 words
- All 21 chapters present (possibly shortened)
- No truncated sentences
- Concluding chapter at the end

FAILURE INDICATORS:
- No concluding chapter → FAIL
- < 20,000 words → FAIL
- Missing chapters → FAIL
- Truncated sentences → FAIL
- References section at the very end (instead of after concluding chapter) → FAIL

═══════════════════════════════════════════════════════════════════════════════
PRIORITY: HIGH
User gave explicit instructions that were completely ignored.
This is a fundamental failure of the app's core purpose.
═══════════════════════════════════════════════════════════════════════════════